"""
Построение бинарного дерева
Option 8
Root = 8; height = 4, left_leaf = root+root/2, right_leaf = root^2
"""


def left_leaf(root: float) -> float:  # левая ветка бинарного дерева
    return root + root / 2


def right_leaf(root: int) -> int:  # правая ветка бинарного дерева
    return root ** 2


def gen_bin_tree(height: int, root: float) -> list:  # бинарное дерево
    '''
    Функция создания бинарного дерева с помощью рекурсии.

    right_leaf(root: int) - функция для правой ветки (root ** 2 при целом root возвращает int),
    left_leaf(root: float) - функция для левой ветки (root + root / 2 при любом root возвращает float)

    Структура дерева:
        - При height = 0 функция возвращает только корень (root)
        - При height > 0 функция рекурсивно строит дерево (левая и правая ветки):
            1. Каждый узел (находится внутри квадратных скобок '[]') представляется как
            [значение, левая_ветка, правая_ветка]
            2. Сначала выводится корень дерева, затем его левая ветка, для каждого значения
            левой ветки выводятся свои левые ветки, на нижнем уровне выводится левое и правое значения,
            правые ветки выводятся после вывода левых веток

    Аргументы:
        - height: высота дерева (максимальное количество узлов на пути от корневого узла до самого дальнего листового узла).
        Может принимать только натуральные значения
        - root: вершина дерева, может принимать положительные числа типа int и float

    Возвращения:
        Бинарное дерево в виде списка списков, каждый из которых является поддеревом основного бинарного дерева

    Пример:
        >>> gen_bin_tree(0, 8) # height = 0
        [8]
        >>> gen_bin_tree(1, 8) # height = 1
        [8, [12.0, 64]]
        >>> gen_bin_tree(2, 8) # height = 2
        [8, [12.0, [18.0, 144.0], 64, [96.0, 4096]]]

    В последнем примере root=8, его левая ветвь: 12.0, [18.0, 144.0], его правая ветвь: 64, [96.0, 4096]
    '''

    if type(root) != int and type(root) != float or type(height) != int: # проверка на тип данных
        return 'Неверный тип данных' # root - положительное число, height - натуральное число

    elif height < 0 or root < 0: # проверка на корректность ввода высоты дерева и его вершины
        return 'Высота и корень дерева не могут быть отрицательными'

    elif height == 0: # возврат вершины при нулевой высоте
        return [root]
    else:
        return [root] + [gen_bin_tree(height - 1, left_leaf(root)) + gen_bin_tree(height - 1, right_leaf(root))] # рекурсия


print(gen_bin_tree(0.5, 2)) # вызов функции
